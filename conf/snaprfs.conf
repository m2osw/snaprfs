# snaprfs configuration
#
# The file is a basic list of `name = value` variables
# Comments start with a # character, must be the first character after spaces
# Empty lines are ignored


# listen=rfs:///<ip>:<port>
#
# The IP address and port to a TCP socket to be created to listen for data
# connections.
#
# This connection only supports the 'rfs' protocol. This is an unencrypted
# protocol so it should only be used between computers on the same cluster
# (i.e. on a LAN).
#
# Default: rfs:///127.0.0.1:4044
listen=rfs:///127.0.0.1:4044


# secure_listen=rfss:///<ip>:<port>
#
# The IP address and port to a TCP socket to be created to listen for
# secure data connections. This specific connection uses a certificate
# and a private key for encryption.
#
# This connection is opened only if the certificate and private_key
# parameters are also defined. By default, it is not set (no defaults)
# and thus no secure connection is available.
#
# Default: <undefined>
#secure_listen=rfs:///127.0.0.1:4045


# certificate=<full path to PEM file>
#
# If a certificate (and private key) is defined, then the snaprfs
# remote connections are done over SSL. Note that SSL really means
# it is encrypted. At time of writing, we only allow TLS v1.2
# connections and no SSL v2 or v3.
#
# Default: /etc/snaprfs/keys/communicatord.crt
certificate=/etc/snaprfs/keys/communicatord.crt


# private_key=<full path to PEM file>
#
# If a private key (and certificate) is defined, then the snaprfs
# remote connections are done over an encrypted connection.
#
# Default: /etc/snaprfs/keys/communicatord.key
private_key=/etc/snaprfs/keys/communicatord.key


# communicatord_listen=cd:///<ip>:<port> | cd:///<path>
#
# The IP address and port or a Unix path to a socket of the communicator
# daemon used to interconnect.
#
# The snaprfs daemon connects to the communicator daemon using this
# information. Once connected, all the other services can access the
# snaprfs daemon via their own local communicator daemon connection.
#
# Default: cd:///run/communicatord/communicatord.sock
communicatord_listen=cd:///run/communicatord/communicatord.sock


# watch_dirs=<path>:<path>:...
#
# The list of paths to watch directories used to listen for file changes
# and sharing.
#
# The default is defined internally and is likely sufficient for most
# installations although some systems may prefer to use different
# settings by updating this file.
#
# Default: /usr/share/snaprfs/watch-dirs:/var/lib/snaprfs/watch-dirs
#watch_dirs=/usr/share/snaprfs/watch-dirs:/var/lib/snaprfs/watch-dirs


# parts=<path>:<path>:...
#
# A list of paths were "parts" are saved. When a file is being transferred
# it gets saved in a separate directory and once the file transfer is
# complete, the "parts" get copied to the final destination as one file.
#
# This list defines a folder where parts are saved while files are being
# transferred. The reason for supporting multiple parts directories is to
# support folders that are on the same physical disk so a "mv ..." command
# just moves the inode from one directory to another instead of copying
# the file between two disks.
#
# The watch_dir configuration files must specify which path to use. If not
# specified, then the service attempts to determine the correct path. If
# that fails, the first <path> defined in the parameter is used.
#
# A part path defined in a watch_dirs configuration file must exist in this
# list to be considered.
#
# Default: /var/lib/snaprfs/parts
#parts=/var/lib/snaprfs/parts


# vim: wrap
